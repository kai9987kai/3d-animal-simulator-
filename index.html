<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced 3D Animal Simulation Environment</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 0; 
      background-color: #f0f2f5; 
      overflow: hidden; 
    }
    #canvasContainer { 
      width: 100vw; 
      height: 100vh; 
    }
    #info { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      z-index: 1;
    }
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div id="canvasContainer"></div>
  <div id="info">Enhanced 3D Animal Simulation<br>Use mouse to orbit camera<br>Scroll to zoom</div>
  <div id="controls">
    <label>Animal Speed:</label>
    <input type="range" id="speedControl" min="0.5" max="5" step="0.1" value="2">
    <br>
    <label>Terrain Complexity:</label>
    <input type="range" id="terrainControl" min="0.1" max="1.5" step="0.1" value="1">
  </div>
  
  <script>
    let scene, camera, renderer, controls, clock;
    let env, animals, skybox;
    let animalSpeed = 2, terrainComplexity = 1;

    class Environment {
      constructor(size) {
        this.size = size;
        this.simplex = new SimplexNoise();
      }

      getHeight(x, y) {
        // Generate height using noise, scaled by terrain complexity
        return this.simplex.noise2D(x * terrainComplexity / 10, y * terrainComplexity / 10) * 5;
      }
    }

    class Animal {
      constructor(environment) {
        this.environment = environment;
        this.position = [
          Math.random() * environment.size,
          Math.random() * environment.size
        ];
        this.energy = 100;
        this.rotation = Math.random() * Math.PI * 2;
      }

      createMesh() {
        const bodyMaterial = new THREE.MeshPhongMaterial({ color: this.getRandomColor() });
        this.mesh = new THREE.Group();

        // Body
        const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        this.mesh.add(body);

        // Head
        const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const head = new THREE.Mesh(headGeometry, bodyMaterial);
        head.position.set(0.5, 0.2, 0);
        this.mesh.add(head);

        // Legs
        this.legs = [];
        for (let i = 0; i < 4; i++) {
          const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
          const leg = new THREE.Mesh(legGeometry, bodyMaterial);
          leg.position.set((i < 2 ? -0.3 : 0.3), -0.3, (i % 2 === 0 ? -0.3 : 0.3));
          leg.rotation.x = Math.PI / 2;
          this.legs.push(leg);
          this.mesh.add(leg);
        }

        this.mesh.castShadow = true;
        scene.add(this.mesh);
        this.updateMeshPosition();
      }

      getRandomColor() {
        const colors = [0xff5555, 0x55ff55, 0x5555ff, 0xffff55, 0xff55ff, 0x55ffff];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      updateMeshPosition() {
        const x = this.position[0] - this.environment.size / 2;
        const z = this.position[1] - this.environment.size / 2;
        const height = this.environment.getHeight(x, z);
        this.mesh.position.set(x, height + 0.5, z);
        this.mesh.rotation.y = this.rotation;

        // Animate legs
        const time = clock.getElapsedTime();
        this.legs.forEach((leg, index) => {
          leg.rotation.z = Math.sin(time * 10 + index) * 0.5;
        });
      }

      move(delta) {
        const angle = this.rotation;
        this.position[0] += Math.cos(angle) * animalSpeed * delta;
        this.position[1] += Math.sin(angle) * animalSpeed * delta;
        
        this.position = this.position.map(pos => {
          if (pos < 0) pos += this.environment.size;
          if (pos >= this.environment.size) pos -= this.environment.size;
          return pos;
        });

        this.rotation += (Math.random() - 0.5) * delta * 2;
      }
    }

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.FogExp2(0x87ceeb, 0.02);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 20, 30);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.shadowMap.enabled = true;
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById("canvasContainer").appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(10, 20, 10);
      light.castShadow = true;
      light.shadow.mapSize.width = 2048;
      light.shadow.mapSize.height = 2048;
      scene.add(light);

      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);

      clock = new THREE.Clock();

      createTerrain();
      createAnimals();
      createSkybox();
      animate();
    }

    function createTerrain() {
      const geometry = new THREE.PlaneGeometry(env.size, env.size, env.size - 1, env.size - 1);
      const positions = geometry.attributes.position.array;

      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const z = positions[i + 1];
        positions[i + 2] = env.getHeight(x, z);
      }

      geometry.attributes.position.needsUpdate = true;
      geometry.computeVertexNormals();

      const material = new THREE.MeshPhongMaterial({
        color: 0x3d8c40,
        shininess: 0,
        flatShading: true
      });
      
      const terrain = new THREE.Mesh(geometry, material);
      terrain.rotation.x = -Math.PI / 2;
      terrain.receiveShadow = true;
      scene.add(terrain);
    }

    function createAnimals() {
      animals.forEach(animal => animal.createMesh());
    }

    function createSkybox() {
      const skyboxLoader = new THREE.CubeTextureLoader();
      skybox = skyboxLoader.load([
        'skybox_px.jpg', 'skybox_nx.jpg',
        'skybox_py.jpg', 'skybox_ny.jpg',
        'skybox_pz.jpg', 'skybox_nz.jpg',
      ]);
      scene.background = skybox;
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      animals.forEach(animal => {
        animal.move(delta);
        animal.updateMeshPosition();
      });

      controls.update();
      renderer.render(scene, camera);
    }

    function simulate() {
      env = new Environment(50);
      animals = Array.from({ length: 20 }, () => new Animal(env));
    }

    // Initialize simulation on load
    window.addEventListener("load", () => {
      simulate();
      initScene();
    });

    // Handle resizing
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Control panel listeners
    document.getElementById("speedControl").addEventListener("input", (e) => {
      animalSpeed = parseFloat(e.target.value);
    });

    document.getElementById("terrainControl").addEventListener("input", (e) => {
      terrainComplexity = parseFloat(e.target.value);
      scene.remove(scene.children.find(child => child.isMesh));
      createTerrain();
    });
  </script>
</body>
</html>
