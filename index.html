<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Realistic 3D Animal Simulation Environment</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 0; 
      background-color: #f0f2f5; 
      overflow: hidden; 
    }
    #canvasContainer { 
      width: 100vw; 
      height: 100vh; 
    }
    #info { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      color: white;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="canvasContainer"></div>
  <div id="info">3D Animal Simulation<br>Use mouse to orbit camera<br>Scroll to zoom</div>
  
  <script>
    let scene, camera, renderer, controls, clock;
    let env, animals;
    
    class Environment {
      constructor(size) {
        this.size = size;
        this.simplex = new SimplexNoise();
      }

      getHeight(x, y) {
        // Generate height using noise for realistic terrain
        return this.simplex.noise2D(x / 10, y / 10) * 5;
      }
    }

    class Animal {
      constructor(environment) {
        this.environment = environment;
        this.position = [
          Math.random() * environment.size,
          Math.random() * environment.size
        ];
        this.energy = 100;
        this.rotation = Math.random() * Math.PI * 2;
      }

      createMesh() {
        const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const bodyMaterial = new THREE.MeshPhongMaterial({ color: this.getRandomColor() });
        this.mesh = new THREE.Group();
        
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        this.mesh.add(body);

        const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const head = new THREE.Mesh(headGeometry, bodyMaterial);
        head.position.set(0.5, 0.2, 0);
        this.mesh.add(head);

        this.mesh.castShadow = true;
        scene.add(this.mesh);
        this.updateMeshPosition();
      }

      getRandomColor() {
        const colors = [0xff5555, 0x55ff55, 0x5555ff, 0xffff55, 0xff55ff, 0x55ffff];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      updateMeshPosition() {
        const x = this.position[0] - this.environment.size / 2;
        const z = this.position[1] - this.environment.size / 2;
        const height = this.environment.getHeight(x, z);
        this.mesh.position.set(x, height + 0.5, z);
        this.mesh.rotation.y = this.rotation;
      }

      move(delta) {
        const speed = 2;
        const angle = this.rotation;
        this.position[0] += Math.cos(angle) * speed * delta;
        this.position[1] += Math.sin(angle) * speed * delta;
        
        this.position = this.position.map(pos => {
          if (pos < 0) pos += this.environment.size;
          if (pos >= this.environment.size) pos -= this.environment.size;
          return pos;
        });
        
        this.rotation += (Math.random() - 0.5) * delta;
      }
    }

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.FogExp2(0x87ceeb, 0.02);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 20, 30);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.shadowMap.enabled = true;
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById("canvasContainer").appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.update();

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(10, 20, 10);
      light.castShadow = true;
      light.shadow.mapSize.width = 2048;
      light.shadow.mapSize.height = 2048;
      scene.add(light);

      const ambientLight = new THREE.AmbientLight(0x404040);
      scene.add(ambientLight);

      clock = new THREE.Clock();

      createTerrain();
      createAnimals();
      animate();
    }

    function createTerrain() {
      const geometry = new THREE.PlaneGeometry(env.size, env.size, env.size - 1, env.size - 1);
      const positions = geometry.attributes.position.array;

      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const z = positions[i + 1];
        positions[i + 2] = env.getHeight(x, z);
      }

      geometry.attributes.position.needsUpdate = true;
      geometry.computeVertexNormals();

      const material = new THREE.MeshPhongMaterial({
        color: 0x3d8c40,
        shininess: 0,
        flatShading: true
      });
      
      const terrain = new THREE.Mesh(geometry, material);
      terrain.rotation.x = -Math.PI / 2;
      terrain.receiveShadow = true;
      scene.add(terrain);
    }

    function createAnimals() {
      animals.forEach(animal => {
        animal.createMesh();
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      animals.forEach(animal => {
        animal.move(delta);
        animal.updateMeshPosition();
      });

      controls.update();
      renderer.render(scene, camera);
    }

    function simulate() {
      env = new Environment(50);
      animals = Array.from({ length: 20 }, () => new Animal(env));
    }

    window.addEventListener("load", () => {
      simulate();
      initScene();
    });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
